import 'package:stockv2/features/pipeline/bloc/contact_opportunity/index.dart';
import 'package:stockv2/features/pipeline/bloc/contact_prospect/index.dart';
import 'package:stockv2/features/pipeline/bloc/lead/contact_bloc.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:syncfusion_flutter_datagrid/datagrid.dart';
import 'package:stockv2/features/pipeline/models/contact_model.dart';
import 'package:stockv2/shared/theme/colors.dart';

class UserDataSource extends DataGridSource {
  UserDataSource({
    required List<ContactModel> employeeData,
    required this.context,
    required this.type,
  }) {
    _contactData = employeeData
        .map<DataGridRow>(
          (e) => DataGridRow(
            cells: [
              DataGridCell<int>(columnName: 'id', value: e.id),
              DataGridCell<String>(columnName: 'name', value: e.fullName),
              DataGridCell<String>(columnName: 'activity', value: e.activity),
              DataGridCell<String>(
                  columnName: 'created_at', value: e.created_at),
              DataGridCell<String>(
                columnName: 'expiryDate',
                value: e.expiryDate?.isEmpty ?? true
                    ? "Date not specified"
                    : e.expiryDate,
              ),
            ],
          ),
        )
        .toList();
  }

  final BuildContext context;
  List<DataGridRow> _contactData = [];
  final String type;

  @override
  List<DataGridRow> get rows => _contactData;

  @override
  DataGridRowAdapter buildRow(DataGridRow row) {
    return DataGridRowAdapter(
      cells: [
        Container(),
        Container(
          alignment: Alignment.center,
          padding: const EdgeInsets.all(2.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(row.getCells()[1].value.toString()),
              const SizedBox(height: 2),
              Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 12, vertical: 2),
                decoration: BoxDecoration(
                  color: const Color(CustomColors.red100F),
                  borderRadius: BorderRadius.circular(12.0),
                ),
                child: const Text(
                  "Hot",
                  style: TextStyle(color: Color(CustomColors.red500F)),
                ),
              ),
            ],
          ),
        ),
        Container(
          alignment: Alignment.center,
          padding: const EdgeInsets.all(2.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(row.getCells()[2].value.toString()),
              const SizedBox(height: 2),
              Text(row.getCells()[3].value.toString()),
            ],
          ),
        ),
        Container(
          alignment: Alignment.center,
          padding: const EdgeInsets.all(2.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(row.getCells()[3].value.toString()),
              const SizedBox(height: 2),
              Text(row.getCells()[3].value.toString()),
            ],
          ),
        ),
        Container(
          alignment: Alignment.center,
          padding: const EdgeInsets.all(2.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(row.getCells()[4].value.toString()),
              const SizedBox(height: 2),
            ],
          ),
        )
      ],
    );
  }

  void _addMoreRows(int count, bool isRefresh) {
    int startIndex = _contactData.isNotEmpty ? _contactData.length : 0;
    int endIndex = startIndex + count;
    int page = ((startIndex + endIndex) ~/ 10).toInt() - 1;
    switch (type) {
      case 'LEAD':
        final contactBloc = BlocProvider.of<ContactBloc>(context);
        if (contactBloc.state is ContactEndOfPageState) {
          return;
        } else if (contactBloc.state is ContactFetchingMoreLoadingState ||
            contactBloc.state is ContactFetchingLoadingState) {
          // still loading
          return;
        } else if (contactBloc.state is ContactFetchingSuccessState) {
          contactBloc.add(
            ContactInitialFetchEvent(
              page: page,
              type: type,
              contacts: _contactData
                  .map(
                    (e) => ContactModel(
                      id: e.getCells()[0].value,
                      fullName: e.getCells()[1].value,
                      activity: e.getCells()[2].value,
                      created_at: e.getCells()[3].value,
                      expiryDate: e.getCells()[4].value,
                      phone: "09",
                      contactStatus: true,
                      contact_owner: "owner",
                    ),
                  )
                  .toList(),
            ),
          );
        }

        break;
      case 'OPPORTUNITY':
        final contactBloc = BlocProvider.of<ContactOpportunityBloc>(context);
        if (contactBloc.state is EndOfPagentactOpportunityStateState) {
          return;
        } else if (contactBloc.state is ContactFetchingMoreLoadingState ||
            contactBloc.state is ContactFetchingLoadingState) {
          // still loading
          return;
        } else if (contactBloc.state is ContactFetchingSuccessState) {
          contactBloc.add(
            LoadContactOpportunityEvent(
              page: page,
              type: type,
              contacts: _contactData
                  .map(
                    (e) => ContactModel(
                      id: e.getCells()[0].value,
                      fullName: e.getCells()[1].value,
                      activity: e.getCells()[2].value,
                      created_at: e.getCells()[3].value,
                      expiryDate: e.getCells()[4].value,
                      phone: "09",
                      contactStatus: true,
                      contact_owner: "owner",
                    ),
                  )
                  .toList(),
            ),
          );
        }
        break;
      case 'PROSPECT':
        final contactBloc = BlocProvider.of<ContactProspectBloc>(context);
        if (contactBloc.state is EndOfPagentactProspectStateState) {
          return;
        } else if (contactBloc.state is ContactFetchingMoreLoadingState ||
            contactBloc.state is ContactFetchingLoadingState) {
          // still loading
          return;
        } else if (contactBloc.state is ContactFetchingSuccessState) {
          contactBloc.add(
            LoadContactProspectEvent(
              page: page,
              type: type,
              contacts: _contactData
                  .map(
                    (e) => ContactModel(
                      id: e.getCells()[0].value,
                      fullName: e.getCells()[1].value,
                      activity: e.getCells()[2].value,
                      created_at: e.getCells()[3].value,
                      expiryDate: e.getCells()[4].value,
                      phone: "09",
                      contactStatus: true,
                      contact_owner: "owner",
                    ),
                  )
                  .toList(),
            ),
          );
        }
        break;
    }
  }

  @override
  Future<void> handleLoadMoreRows() async {
    await Future.delayed(const Duration(seconds: 1));
    _addMoreRows(10, false);
    notifyListeners();
  }

  @override
  Future<void> handleRefresh() async {
    await Future.delayed(const Duration(seconds: 1));
    final contactBloc = BlocProvider.of<ContactBloc>(context);
    contactBloc.add(ContactInitialFetchEvent(
      page: 0,
      type: type,
      contacts: [],
    ));
    notifyListeners();
  }
}
